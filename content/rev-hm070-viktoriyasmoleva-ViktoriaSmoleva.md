https://github.com/ViktoriaSmoleva/HangManSmoleva/tree/master  
[Виктория Смолева]

Игра в процедурном стиле, выполнена в одном классе.

## НЕДОСТАТКИ РЕАЛИЗАЦИИ

1. Повторный ввод неправильной буквы засчитывается в качестве новой ошибки
```
Введите букву: 
й
Не правильно, попробуем еще раз
        +------+
        |      O
        |
        |
        |
      =====

Осталось попыток: 5
Список введенных букв: й
******
Введите букву: 
й
Не правильно, попробуем еще раз
        +------+
        |      O
        |      |
        |
        |
      =====

Осталось попыток: 4
Список введенных букв: йй
```

2. При повторных вводах одной и той же неправильной буквы, она снова добавляется в список введенных букв
```
         +------+
         |      O
         |     /|\
         |     / \
         |
       =====

Осталось попыток: 0
Список введенных букв: йййййй
Вы проиграли. Загаданное слово стекло
```

3. "Неправильно" здесь должно быть слитно
```
Не правильно, попробуем еще раз
```

4. Можно ввести не одну букву, а сразу целое слово и это будет считаться допустимым вводом
```
Введите букву: 
кукуку
Есть такая буква в слове!
Список введенных букв: цабк
к**к**
```

5. Можно ввести не только русскую букву, но английскую букву, цифру и все что угодно
```
Введите букву: 
#
Не правильно, попробуем еще раз
         +------+
         |      O
         |     /|\
         |     / \
         |
       =====

Осталось попыток: 0
Список введенных букв: qw123#
Вы проиграли. Загаданное слово штопка
```

Игра должна соответствовать требованиям:
- Принимать только одиночные буквы алфавита отгадываемых слов, в данном случае- русского алфавита
- Не засчитывать повторный ввод неправильных букв в качестве ошибки и не вносить повторно эту букву в список введенных

## ХОРОШО

1. Игра запускается
2. Есть список введенных букв
3. Простой понятный алгоритм

## ЗАМЕЧАНИЯ

**1. Нейминг**

- Не экономь буквы, старайся писать слова полностью, если их длина будет в разумных пределах. 
Буквы экономили в старину потому что мониторы в текстовом режиме были размером 80x25 символов, а сейчас таких ограничений нет
```
Scanner sc 

//ПРАВИЛЬНО:
Scanner scanner
```

- UPPER_SNAKE только для констант, а это не константа
```
private static int ATTEMPTS_COUNT = 6;

//ПРАВИЛЬНО:
private static int attemptsCount = 6;
```

- Старайся не называть экземпляры разных классов одинаковыми названиями, это приводит к путанице
```
StringBuilder guessedLetters
String guessedLetters
```

- Название методов должны быть глаголом в повелительном наклонении и объяснять, какое действие метод выполняет 
```
public static String[] gallows()

//ПРАВИЛЬНО:
public static String[] printGallows()
```

- Название метода вводит в заблуждение. Метод не проверяет на выигрыш, хотя и возвращает boolean. Метод распечатывает сообщение при выигрыше
```
private static boolean isWin() {
  System.out.println("Вы выиграли!!!!! Загаданное слово " + hiddenWord);
  System.out.println();
  return true;
}

//ПРАВИЛЬНО:
private static void printWinMessage() {
  System.out.println("Вы выиграли!!!!! Загаданное слово " + hiddenWord);
  System.out.println();
}
```
То же самое касается `isLose()`

*Oracle Java code conventions, part."Naming conventions"*  
*Мартин, "Чистый код", гл.2*  
*Ютуб, Немчинский "Как называть переменные, методы и классы?"*  

**2. Когда нет разницы, используй постфиксную форму инкремента(i++)**, а не префиксную(++i).
Иначе при рефакторинге можно надолго зависнуть вспоминая отличия постинкремена и преинкремена, а отличия между ними есть. 
Используй преинкремент(++n) только тогда, когда нужен именно преинкремент
```
++n;

//ПРАВИЛЬНО:
n++;
```

**3. Нарушение конвенции кода.** В любой ситуации выделяй тело блока скобочками. Исключение- метод equals()
```
if (random.nextInt(n) == 0) 
  maskWord = line;      

//ПРАВИЛЬНО:
if (random.nextInt(n) == 0) {
  maskWord = line;
}
```

**4. Нарушение DRY**, магические буквы, числа, слова. Вводи константы 
```
maskedWord.append('*');
if (maskWord(hiddenWord, guessedLetters.toString()).indexOf('*') < 0) {...}

System.out.println("Если хотите начать новую игру введите 'да', если хотите выйти введите 'нет':");
if (input.equalsIgnoreCase("да")) {
  //...
} else if (input.equalsIgnoreCase("нет")) {...}

//ПРАВИЛЬНО:
private final static char MASK_SYMBOL = '*';
private final static String START = "да";
private final static String QUIT = "нет";

maskedWord.append(MASK_SYMBOL);
if (maskWord(hiddenWord, guessedLetters.toString()).indexOf(MASK_SYMBOL) < 0) {...}

System.out.printf("Если хотите начать новую игру введите '%s', если хотите выйти введите '%s': %n", START, QUIT);
if (input.equalsIgnoreCase(START)) {
  //...
} else if (input.equalsIgnoreCase(QUIT)) {...}
```

*Фаулер, "Рефакторинг", гл.8 п."Замена магического числа символической константой"*   
*refactoring.guru "Замена магического числа символьной константой"* 


**5. Слишком длинные конструкции**, которые трудно понять.
```
System.out.println(maskWord(hiddenWord, guessedLetters.toString()));

//ПРАВИЛЬНО:
String mask = maskWord(hiddenWord, guessedLetters.toString())
System.out.println(mask);
```
Вводи поясняющие переменные.

*Фаулер, "Рефакторинг", гл.6,п."Введение поясняющей переменной"*  

**6. Создавай вспомогательные методы**, делай программу более простой и понятной. Иногда это еще помогает избавиться от дублирования кода
```
if (hiddenWord.toLowerCase().indexOf(c) >= 0) {...}
if (guessedLetters.indexOf(currentChar) >= 0) {...}

//ПРАВИЛЬНО:
if (contains(hiddenWord, c)) {...}
if (contains(guessedLetters, currentChar)) {...}

private boolean contains(String word, char letter) {
  letter = Character.toLowerCase(letter);
  return word.toLowerCase().indexOf(letter) >= 0;
}
```

**7. Продумывай, где лучше размещать переменные**, в поле метода или класса. В каждом отдельном случае это будет индивидуально.

Здесь переменные "Скрытое слово" и "Угаданные буквы" с "Введенными буквами" это равноценные участники процесса и должны быть полями класса, а не метода.
Это упростит их применение в программе, так как сейчас guessedLetters и enteredLetters приходится постоянно кидать между методами путем передачи этих переменных во входящие методов.
В данном случае лучше будет, если методы будут брать эти данные из окружения, а не из входящих аргументов
```
public class HangMan {
  private static String hiddenWord;
  //...  
  public static void playGame(String word) {
    StringBuilder guessedLetters = new StringBuilder();
    StringBuilder enteredLetters = new StringBuilder();
    //...
  }
}    

//ТУТ ПРАВИЛЬНО:
public class HangMan {
  private static String hiddenWord;
  private static StringBuilder guessedLetters = new StringBuilder();
  private static StringBuilder enteredLetters = new StringBuilder();
  //...  

  public static void playGame(String word) {
    //...
  }
}    
```
Общее правило: если одни и те же данные в одном и том же смысловом контексте используются разными методами, эти данные нужно делать полем класса. 
Если данные нужны только внутри одного метода, они должны быть полем метода.

**8. Разделяй команды и запросы**. Этот метод должен или выполнить действие, то есть распечатать изображение виселицы. Или вернуть изображение виселицы, то есть выполнить запрос. Но не то и другое вместе
```
public static String[] gallows() {
    String[] gallows = new String[]{...};
    System.out.println(gallows[6 - ATTEMPTS_COUNT]);   //распечатка- выполнение команды
    return gallows;  //возврат данных- выполнение запроса
  }
```
*Мартин, "Чистый код", гл.3, п."Разделение команд и запросов"*  

**9. Методы проверки на выигрыш и проигрыш нужны**, но сделаны здесь неправильно
```
if (maskWord(hiddenWord, guessedLetters.toString()).indexOf('*') < 0) {  //сейчас это проверка на выигрыш
    isWin(); //сейчас этот метод не проверяет на выигрыш
    return;
}
//...

private static boolean isWin() {
  System.out.println("Вы выиграли!!!!! Загаданное слово " + hiddenWord);
  System.out.println();
  return true;
}

//ПРАВИЛЬНО:
if (isWin()) {  
    printWinMessage();
    return;
}
//...

private static boolean isWin() {
  String mask = maskWord(hiddenWord, guessedLetters.toString()); //guessedLetters тут- поле класса
  return mask.indexOf(MASK_SYMBOL) < 0;
}
```

**10. Цикл while** всегда лучше читается, когда он написан в варианте `while() {...}`, а не `do {...} while()` - тогда сразу видно условие входа в цикл и выхода из него. 
Если есть возможность, `do-while` нужно переделывать на обычный `while`
```
do {
    //...
    //...
    //...
    //...
    //...
    //...
    //...
    //...
    //...
  //еще миллион строк  
} while (ATTEMPTS_COUNT > 0); 

//ЛУЧШЕ:
while (ATTEMPTS_COUNT > 0) {
    //...
    //...
    //...
    //...
    //...
    //...
    //...
    //...
    //...
  //еще миллион строк  
}
```

**11. Картинки висельницы нужно сделать константой**, потому картинки нужны на протяжение всей игры. Если их сделать константами, то они создадутся один раз. 
Сейчас картинки это поле метода, значит они создаются каждый раз, когда вызывается этот метод- избыточное расходование ресурсов
```
public class HangMan {

  //...
  public static String[] gallows() {
    String[] gallows = new String[]{
        """
        +------+
        |
        |
        |
        |
      =====
    """,
    //oth's
    }
  }
}  

//ПРАВИЛЬНО:
public class HangMan {

  private static final String[] PICTURES = { //можно без `new String[]`
        """
        +------+
        |
        |
        |
        |
      =====
    """,
    //oth's
  }

  //...  
}  
```

**12. Вынеси картинки и метод их распечатки в отдельный класс**, процедурный стиль программирования дозволяет делать несколько классов. Тогда в основном классе логика игры не будет смешиваться с графикой.

**13. Вынеси чтение файла в отдельный класс**, тоже будет хорошо.

## ВЫВОД

Для новичка приемлемо, но нужно убрать баги. Посмотри ролики Немчинского по книге "Чистый код": "Как называть переменные, методы и классы?", "Правильные методы по Clean Code", "Как форматировать код правильно?" и другие.

n.70(130)  
#ревью #виселица #игразапускается