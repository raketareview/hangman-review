https://github.com/nikita-webdev/Hangman
[Никита]

Реализация стремится в направлении ООП стиля, но декомпозиция классов выполнена неправильно.  
Поэтому критика будет как к программе, написанной в стиле ООП.

## НЕДОСТАТКИ РЕАЛИЗАЦИИ

1. Вешается одноногий
```
      _____
     |     |
     O     |
    /|\    |
    /      |
          _|_
Число ошибок: 5
Ранее вы вводили буквы: [а, р, е, н, г, ш, в]
Введите букву из слова: 
****анн****
п
Вы проиграли. Загаданное слово: обязанность
```

## ХОРОШО

1. Игра запускается
2. Есть список ранее введенных букв
3. Можно ввести только одиночную букву русского алфавита

## ЗАМЕЧАНИЯ

**1. Нейминг**

- На момент входа в метод еще неизвестно, являетсяли строка буквой. Это станет известно только по результатам валидации
```
public ValidationResult validation(String letter)

//ПРАВИЛЬНО:
public ValidationResult validation(String s)
```

- Название метода вводи в заблуждение- обещает распечатать виселицу, а на самом деле возвращает катинку виселицы
```
public String[] printGallows(int numStage) {
  return GALLOWS_STAGES[numStage];
}
```

*Oracle Java code conventions, part."Naming conventions"*  
*Мартин, "Чистый код", гл.2*  

**2. Слишком длинные конструкции**, которые трудно понять.
```
for (int i = 0; i < gallows.printGallows(gamer.getMistakesCounter()).length; i++) {...}

//ПРАВИЛЬНО:
int rows = gallows.printGallows(gamer.getMistakesCounter()).length;
for (int i = 0; i < rows; i++) {...}
```
Вводи поясняющие переменные

*Фаулер, "Рефакторинг", гл.6,п."Введение поясняющей переменной".*  

**3. Нарушение DRY**, магические буквы, числа, слова. Вводи константы
```
if (lettersInWord == 0 || gamer.getMistakesCounter() == 6) {...}

//ПРАВИЛЬНО:
private final static int MAX_MISTAKES = 6;

if (lettersInWord == 0 || gamer.getMistakesCounter() == MAX_MISTAKES) {...}
```
*Фаулер, "Рефакторинг", гл.8 п."Замена магического числа символической константой"*   
*refactoring.guru "Замена магического числа символьной константой"*  

**4. Создавай вспомогательные методы**, делай программу более простой и понятной
```
if (lettersInWord == 0 || gamer.getMistakesCounter() == 6) {
  if (lettersInWord == 0) {
    System.out.printf("Вы выиграли! Загаданное слово: %s%n%n", word);
  } else {
    System.out.printf("Вы проиграли. Загаданное слово: %s%n%n", word);
  }
  //....
}  

//ПРАВИЛЬНО:
if (isGameOver()) {
  if (isWin() {
    printWinMessage();
  } else {
    printLoseMessage();
  }
  //....
}  
```

**5. class Gallows**

- Нарушение SRP, божественный метод. Класс содержит в себе полностью или частично разные ответственности: 
  - Картинка хангмана и их распечатка 
  - Чтение файла со словами и выдача случайного слова
  - Валидация введенного символа
  - Создание маски слова

Класс нужно разделить на несколько, каждый из которых будет содержать только одну отвественность.  

+ (+)Картинки хранятся в массиве-константе, это хорошо.     

**6. class Gamer**

- Нарушение SRP, божественный метод. Класс содержит в себе разные ответственности: 
  - Счетчик ошибок 
  - Хранилище введенных букв

- Название класса не соответствует тому, что делает класс. 
Класс с именем "Игрок" може содержать только данные для его идентификации и его игровые ресурсы. Например имя, количество денег для ставок и т.д.
Чаще всего Игроки используются в многопользовательских играх типа шахматы и т.д.

- При повторном вводе ранее введенной буквы в хранилище букв, нужно бросать исключение
```
public void addEnteredLetter(String letter) {
  if (!hasEnteredLetter(letter)) {
    enteredLetters.add(letter);
  }
}

//ПРАВИЛЬНО:
public void addEnteredLetter(String letter) {
  if (hasEnteredLetter(letter)) {
    //TODO бросить исключение
  }
  enteredLetters.add(letter);
}
```

**7. class Game**

- По сравнению с остальными классами кажется, что это писал другой человек. 
При всех претензиях к предыдущим классам, они были разделены на короткие методы.
Здесь же есть божественный метод `void start()` длиной в 73 строки.  
Метод выполняет более одного действия, метод нужно разделить на несколько.

- Нарушение инкапсуляции, все поля и методы кроме `start()` должны быть приватные.

- Магические цифры: 6, 10, -1.

**8. class Main**, содержит точку входа main

+ (+)Только создает и запускает Игру, это хорошо. Код почти образцовый.

- Нет смысла в том, что константы публичные.

- Создавать экземпляр Игры нужно только после того, как юзер подтвердил свое намерение играть.

## АРХИТЕКТУРА

Впечатление двоякое.  
С одной стороны, акууратные маленькие методы, хороший нейминг, замечаний относительно немного.  
С другой- суперметод `start()`, куда навалено все. Из-за этого метода код трудно читается.

Если рассматривать программу, как написаную в процедурном стиле, то в принципе все ок- здесь классы это просто контейнеры для функций.  
Если рассматривать программу, как написанную в ООП стиле, то декомпозиция выполнена неправильно. Раздели классы по ответственностям.

## ВЫВОД

Для лучшего понимания декомпозиции посмотреть ролики Сергея про шахматы.  
Посмотреть ролики Немчинского про SOLID- по одному ролику на каждую букву.

n.67(124)  
#ревью #виселица