https://github.com/L1nkolln/hangman/tree/main/Hangman  
[Michael Blumin]

Реализация стремится в направлении ООП стиля.  
Простейший функционал. Много багов.  
Игра запускается, но здесь это ни о чем не говорит- слова не считываются из файла, они жестко прописаны в коде.

## НЕДОСТАТКИ РЕАЛИЗАЦИИ

1. Почему в одном случае в конце одной и той же надписи стоит точка, а в конце другой такой же не стоит?
```
>g
Введите число 1 или 2
>0
Введите число 1 или 2.
>
```

2. Нет списка неправильно веденных букв.
3. Можно ввести не одну букву, а целое слово и это будет считаться допустимым вводом.
4. Можно ввести не только русскую букву, но английскую букву, цифру и все что угодно.

5. Один и тот же неправильный символ можно ввести несколько раз и каждый раз программа это принимает и увеличивает счетчик ошибок
```
Введите букву: 
q
Буква: q Отсутвует
Слово __________
---------
|       |
0       |
|\      |
        |
        |
---------------

Введите букву: 
q
Буква: q Отсутвует
Слово __________
 ---------
 |       |
 0       |
/|\      |
         |
         |
 ---------------

Введите букву: 
q
Буква: q Отсутвует
Слово __________
 ---------
 |       |
 0       |
/|\      |
  \      |
         |
 ---------------
```

6. Вешается одноногий
```
 ---------
 |       |
 0       |
/|\      |
  \      |
         |
 ---------------

Введите букву: 
г
Буква: г Отсутвует
Вы проиграли, слово: солнце
```

## ХОРОШО

1. Простой понятный алгоритм

## ЗАМЕЧАНИЯ

**1. Нейминг**

- Метод увеличивает количество ошибок на 1, то есть инкрементирует
```
void addMistake()

//ПРАВИЛЬНО:
void incMistakes()
```

*Oracle Java code conventions, part."Naming conventions"*  
*Мартин, "Чистый код", гл.2*  

**2. Нарушение DRY**, магические буквы, числа, слова. Вводи константы
```
System.out.println("1. Начать новую игру");
System.out.println("2. Выйти из игры");

if (choice == 1) {
  //...
} else if (choice == 2) {
  //...
}

//ПРАВИЛЬНО:
private final static int START = 1;
private final static int QUIT = 2;

System.out.println(START + ". Начать новую игру");
System.out.println(QUIT + ". Выйти из игры");

if (choice == START) {
  //...
} else if (choice == QUIT) {
  //...
}
```
*Фаулер, "Рефакторинг", гл.8 п."Замена магического числа символической константой"*   
*refactoring.guru "Замена магического числа символьной константой"*  

**2. Нарушение DRY**, классический пример последствий дублирования кода. Рассинхронизация кода: в одном месте текст с точкой, в другом без
```
System.out.println("Введите число 1 или 2.");
//...
System.out.println("Введите число 1 или 2");
```
Вводи константы.

**3. Комментарии**

Коментарии тут не несут полезной нагрузки, а констатируют очевидное
```
private static void showMenu() { // показывает меню
```
...или обманывают- метод не проверяет ввод пользователя, как обещает комментарий, метод вводит данные от пользователя
```
private static int getUserChoice(Scanner scanner) { // проверяет ввод пользователя
```
Когда в проекте много каментов, это плохо- пользы от них практически нет, они только забивают пространство и мешают читать код.
В идеале, комментариев вообще не должно быть, код должен объяснять сам себя через правильный нейминг и лаконичный код.

*Мартин, "ЧК", гл.4*  

**4. Если в блоке if есть return**(break, continue, throw, exit и т.д.), то else не пишется - в этом случае неважно, будет else или нет, так как программа будет работать одинаково
```
if (scanner.hasNextInt()) {
  return scanner.nextInt();
} else {
  System.out.println("Введите число 1 или 2");
}

//ПРАВИЛЬНО:
if (scanner.hasNextInt()) {
  return scanner.nextInt();
}
System.out.println("Введите число 1 или 2");
```

**5. Если нужно печатать текст** с более, чем одним подстановочным значением или значение вставляется внутрь сообщения, используй форматированный вывод- тогда сразу будет виден весь шаблон
```
System.out.println("Буква: " + guess + " Отсутвует");

//ПРАВИЛЬНО:
System.out.printf("Буква: %s Отсутвует \n", guess);
```

**6. Создавай вспомогательные методы**, делай программу более простой и понятной
```
if (String.valueOf(guessedWord).equals(wordToGuess)) {...}
  
//ПРАВИЛЬНО:
if (isВыиграл()) {...}

private boolean isВыиграл() {
  return String.valueOf(guessedWord).equals(wordToGuess);
}
```

**7. class WordGeneration** 

- Тут жестко прописан массив слов для игры. Хангман и так предельно простая игра, не нужно ее еще больше упрощать. 
Слова для игры должны храниться в файле, а этот класс их должен прочитать из файла и только потом выдать случайное слово.

**8. class HangmanDisplay** 

В этом классе находятся картинки хангмана и их распечатка, счетчик ошибок и проверка конца игры.
- (±)Если рассматривать этот класс с точки зрения процедурного программирования, то пойдет- этот класс просто ящик с какими-то методами.

- Если рассматривать это с точки зрения ООП, то это нарушение SRP- в одном классе собраны 3 сущности:  
а) Рендерер висельницы  
б) Собственно хангман- человек, которого вешают  
в) Отдельная сущность Определитель результатов игры(либо часть сущности Игра в части определения конца игры)

+Хранение картинок хангмана в статическом массиве это хорошо

**9. class GameSession**  

- Переменная не используется: `private int maxAttempts`. Значение этого поля класс принимает в конструктор.

- Метод выполняет несколько действий: проверяет наличие буквы в слове, открывает букву, печатает сообщение если буква отутствует
```
private boolean proccessGuess(char guess) {
  boolean isCorrect = false;

  for (int i = 0; i < wordToGuess.length(); i++) {
    if (wordToGuess.charAt(i) == guess && guessedWord[i] == '_') {
      guessedWord[i] = guess;
      isCorrect = true;
    }
  }

  if (!isCorrect) {
    System.out.println("Буква: " + guess + " Отсутвует");
  }
  return isCorrect;
}
```
Метод нужно разделить на несколько, каждый из которых будет делать только свое.

- Магическое: `'_'`

**10. class HangmanGame**, содержит точку входа main

+ (+)Делает только то, что должен- ведет диалог с пользователем и по его результатам создает и запускает Игру(GameSession)

**11. Делай проверку по чеклисту**  
В ТЗ есть пункт `Чеклист для самопроверки`, после выполнения проекта нужно выполнить проверку по этому чеклисту.
Например, там уже есть такие пункты
```
Повторно вводимый символ, отсутствующий в секретном слове, не должен считаться за ошибку

Путь к файлу со словарем слов указан как абсолютный, следует указывать как относительный <--- а у тебя файла-словаря нет совсем

Недостаточная разбивка кода на функции. Одна функция должна отвечать за одну задачу, например, открывать отгаданную букву в маске загаданного слова
``` 

## АРХИТЕКТУРА

Несмотря на то, что в проекте несколько классов, он написан в процедурном стиле.

Программа в ООП стиле должна быть декомпозирована по правилам ООП и использовать ООП подход для реализации типичных задач.
Здесь я этого не вижу, методы в классах собраны по непонятному принципу.
С точки зрения ООП нормально сделаны только HangmanGame и WordGeneration(не учитывая его куций функционал)

Из невыявленных сущностей самая очевидная здесь это **Замаскированное слово**.  
Оно имеет состояния:   
- Секретное слово  
- Маска  

И поведение:  
- Вернуть секретное слово  
- Вернуть маску  
- Сказать, есть ли буква в слове  
- Открыть букву в маске, а если такой буквы в слове нет- кинуть исключение  
- Сказать, открыта ли маска полностью(т.е. слово отгадано)  
Все это должно находиться в отдельном классе. Кроме этого в классе не должно быть других методов.  

Не обязательно, но для тренировки декомпозиции можно сделать в виде классов еще такие сущности:

**Висельник**  
Состояния: текущая стадия повешения, максимальная стадия повешения.  
Поведение: сказать текущую стадию повешения, максимальную стадию, сказать жив или мертв, увеличить стадию повешения.  

**Хранилище букв**  
Состояние: список букв  
Поведение: вернуть список букв, добавить букву(если такая буква уже есть- кинуть исключение), сказать есть ли такая буква в хранилище  

## ВЫВОД

Задание не выполнено в полном объеме, игровой процесс происходит неправильно. Проект нужно дорабатывать. 

n.66(122)  
#ревью #виселица